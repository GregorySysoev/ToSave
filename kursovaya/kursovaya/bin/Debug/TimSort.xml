<?xml version="1.0"?>
<doc>
    <assembly>
        <name>TimSort</name>
    </assembly>
    <members>
        <member name="T:System.Linq.TimSortExtender">
            <summary>
            <![CDATA[T[], List<T> and IList<T>]]> extender providing TimSort extension methods.
            </summary>
        </member>
        <member name="M:System.Linq.TimSortExtender.TryNativeTimSort``1(``0[],System.Int32@,System.Int32@,System.Int32@)">
            <summary>Tries to use native sorting on given array.</summary>
            <typeparam name="T">Any type.</typeparam>
            <param name="array">The array.</param>
            <returns><c>true</c> if sorted using native types, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:System.Linq.TimSortExtender.TryNativeTimSort``1(``0[],System.Int32,System.Int32)">
            <summary>Tries to use native sorting on given array.</summary>
            <typeparam name="T">Any type.</typeparam>
            <param name="array">The array.</param>
            <param name="lo">The low limit.</param>
            <param name="hi">The high limit.</param>
            <returns><c>true</c> if sorted using native types, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:System.Linq.TimSortExtender.TimSort``1(``0[],System.Int32@,System.Int32@,System.Int32@)">
            <summary>Sorts the specified array.</summary>
            <typeparam name="T">Type of item.</typeparam>
            <param name="array">The array.</param>
        </member>
        <member name="M:System.Linq.TimSortExtender.TimSort``1(``0[],System.Int32,System.Int32)">
            <summary>Sorts the specified array.</summary>
            <typeparam name="T">Type of item.</typeparam>
            <param name="array">The array.</param>
            <param name="start">The start.</param>
            <param name="length">The length.</param>
        </member>
        <member name="M:System.Linq.TimSortExtender.TimSort``1(``0[],System.Int32,System.Int32,System.Comparison{``0})">
            <summary>Sorts the specified array.</summary>
            <typeparam name="T">Any type.</typeparam>
            <param name="array">The array.</param>
            <param name="start">The start.</param>
            <param name="length">The length.</param>
            <param name="compare">The compare method.</param>
            <exception cref="T:System.ArgumentNullException">array or compare</exception>
        </member>
        <member name="M:System.Linq.TimSortExtender.TimSort``1(``0[],System.Comparison{``0})">
            <summary>Sorts the specified array.</summary>
            <typeparam name="T">Any type.</typeparam>
            <param name="array">The array.</param>
            <param name="compare">The compare method.</param>
            <exception cref="T:System.ArgumentNullException">array or compare</exception>
        </member>
        <member name="M:System.Linq.TimSortExtender.TimSort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.Comparer{``0})">
            <summary>Sorts the specified array.</summary>
            <typeparam name="T">Any type.</typeparam>
            <param name="array">The array.</param>
            <param name="start">The start.</param>
            <param name="length">The length.</param>
            <param name="comparer">The comparer.</param>
            <exception cref="T:System.ArgumentNullException">array or compare</exception>
        </member>
        <member name="M:System.Linq.TimSortExtender.TimSort``1(``0[],System.Collections.Generic.Comparer{``0})">
            <summary>Sorts the specified array.</summary>
            <typeparam name="T">Any type.</typeparam>
            <param name="array">The array.</param>
            <param name="comparer">The comparer.</param>
            <exception cref="T:System.ArgumentNullException">array or compare</exception>
        </member>
        <member name="M:System.Linq.TimSortExtender.TryInternalTimSort``1(System.Collections.Generic.List{``0},System.Int32,System.Int32)">
            <summary>Tries to extract internal representation and sort it (it should be much faster).</summary>
            <typeparam name="T">Any type.</typeparam>
            <param name="list">The list.</param>
            <param name="start">The start.</param>
            <param name="length">The length.</param>
            <returns><c>true</c> if succeeded, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:System.Linq.TimSortExtender.TryInternalTimSort``1(System.Collections.Generic.List{``0},System.Int32,System.Int32,System.Comparison{``0})">
            <summary>Tries to extract internal representation and sort it (it should be much faster).</summary>
            <typeparam name="T">Any type.</typeparam>
            <param name="list">The list.</param>
            <param name="start">The start.</param>
            <param name="length">The length.</param>
            <param name="compare">The compare method.</param>
            <returns><c>true</c> if succeeded, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:System.Linq.TimSortExtender.TimSort``1(System.Collections.Generic.List{``0})">
            <summary>Sorts the specified array.</summary>
            <typeparam name="T">Type of item.</typeparam>
            <param name="array">The array.</param>
        </member>
        <member name="M:System.Linq.TimSortExtender.TimSort``1(System.Collections.Generic.List{``0},System.Int32,System.Int32)">
            <summary>Sorts the specified array.</summary>
            <typeparam name="T">Type of item.</typeparam>
            <param name="array">The array.</param>
            <param name="start">The start.</param>
            <param name="length">The length.</param>
        </member>
        <member name="M:System.Linq.TimSortExtender.TimSort``1(System.Collections.Generic.List{``0},System.Int32,System.Int32,System.Comparison{``0})">
            <summary>Sorts the specified array.</summary>
            <typeparam name="T">Any type.</typeparam>
            <param name="array">The array.</param>
            <param name="start">The start.</param>
            <param name="length">The length.</param>
            <param name="compare">The compare method.</param>
            <exception cref="T:System.ArgumentNullException">array or compare</exception>
        </member>
        <member name="M:System.Linq.TimSortExtender.TimSort``1(System.Collections.Generic.List{``0},System.Comparison{``0})">
            <summary>Sorts the specified array.</summary>
            <typeparam name="T">Any type.</typeparam>
            <param name="array">The array.</param>
            <param name="compare">The compare method.</param>
            <exception cref="T:System.ArgumentNullException">array or compare</exception>
        </member>
        <member name="M:System.Linq.TimSortExtender.TimSort``1(System.Collections.Generic.List{``0},System.Int32,System.Int32,System.Collections.Generic.Comparer{``0})">
            <summary>Sorts the specified array.</summary>
            <typeparam name="T">Any type.</typeparam>
            <param name="array">The array.</param>
            <param name="start">The start.</param>
            <param name="length">The length.</param>
            <param name="comparer">The comparer.</param>
            <exception cref="T:System.ArgumentNullException">array or compare</exception>
        </member>
        <member name="M:System.Linq.TimSortExtender.TimSort``1(System.Collections.Generic.List{``0},System.Collections.Generic.Comparer{``0})">
            <summary>Sorts the specified array.</summary>
            <typeparam name="T">Any type.</typeparam>
            <param name="array">The array.</param>
            <param name="comparer">The comparer.</param>
            <exception cref="T:System.ArgumentNullException">array or compare</exception>
        </member>
        <member name="M:System.Linq.TimSortExtender.TryInternalTimSort``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
            <summary>Tries to extract internal representation and sort it (it should be much faster).</summary>
            <typeparam name="T">Any type.</typeparam>
            <param name="list">The list.</param>
            <param name="start">The start.</param>
            <param name="length">The length.</param>
            <returns><c>true</c> if succeeded, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:System.Linq.TimSortExtender.TryInternalTimSort``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,System.Comparison{``0})">
            <summary>Tries to extract internal representation and sort it (it should be much faster).</summary>
            <typeparam name="T">Any type.</typeparam>
            <param name="list">The list.</param>
            <param name="start">The start.</param>
            <param name="length">The length.</param>
            <param name="compare">The compare method.</param>
            <returns><c>true</c> if succeeded, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:System.Linq.TimSortExtender.TimSort``1(System.Collections.Generic.IList{``0})">
            <summary>Sorts the specified array.</summary>
            <typeparam name="T">Type of item.</typeparam>
            <param name="array">The array.</param>
        </member>
        <member name="M:System.Linq.TimSortExtender.TimSort``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
            <summary>Sorts the specified array.</summary>
            <typeparam name="T">Type of item.</typeparam>
            <param name="array">The array.</param>
            <param name="start">The start.</param>
            <param name="length">The length.</param>
        </member>
        <member name="M:System.Linq.TimSortExtender.TimSort``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,System.Comparison{``0})">
            <summary>Sorts the specified array.</summary>
            <typeparam name="T">Any type.</typeparam>
            <param name="array">The array.</param>
            <param name="start">The start.</param>
            <param name="length">The length.</param>
            <param name="compare">The compare method.</param>
            <exception cref="T:System.ArgumentNullException">array or compare</exception>
        </member>
        <member name="M:System.Linq.TimSortExtender.TimSort``1(System.Collections.Generic.IList{``0},System.Comparison{``0})">
            <summary>Sorts the specified array.</summary>
            <typeparam name="T">Any type.</typeparam>
            <param name="array">The array.</param>
            <param name="compare">The compare method.</param>
            <exception cref="T:System.ArgumentNullException">array or compare</exception>
        </member>
        <member name="M:System.Linq.TimSortExtender.TimSort``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,System.Collections.Generic.Comparer{``0})">
            <summary>Sorts the specified array.</summary>
            <typeparam name="T">Any type.</typeparam>
            <param name="array">The array.</param>
            <param name="start">The start.</param>
            <param name="length">The length.</param>
            <param name="comparer">The comparer.</param>
            <exception cref="T:System.ArgumentNullException">array or compare</exception>
        </member>
        <member name="M:System.Linq.TimSortExtender.TimSort``1(System.Collections.Generic.IList{``0},System.Collections.Generic.Comparer{``0})">
            <summary>Sorts the specified array.</summary>
            <typeparam name="T">Any type.</typeparam>
            <param name="array">The array.</param>
            <param name="comparer">The comparer.</param>
            <exception cref="T:System.ArgumentNullException">array or compare</exception>
        </member>
        <member name="T:System.Linq.TimSortExtender.SorterProxy">
            <summary>Proxy object to resolve sorter dynamically.</summary>
        </member>
        <member name="F:System.Linq.TimSortExtender.SorterProxy.SortAll">
            <summary>The sort all proxy.</summary>
        </member>
        <member name="F:System.Linq.TimSortExtender.SorterProxy.SortRange">
            <summary>The sort range proxy.</summary>
        </member>
        <member name="M:System.Linq.TimSortExtender.IsIComparable``1">
            <summary>Determines whether type implements IComparable.</summary>
            <typeparam name="T">Any type.</typeparam>
            <returns><c>true</c> if  implements IComparable; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:System.Linq.TimSortExtender.GetComparableSorterProxy``2(System.Type)">
            <summary>Gets the sorter proxy for IComparable.</summary>
            <typeparam name="TContainer">The type of the container.</typeparam>
            <typeparam name="TItem">The type of the item.</typeparam>
            <param name="sorterType">Type of the sorter.</param>
            <returns>Sorter proxy.</returns>
        </member>
        <member name="M:System.Linq.TimSortExtender.TryComparableTimSort``1(``0[])">
            <summary>Tries sorting as IComparable.</summary>
            <typeparam name="TItem">Item type.</typeparam>
            <param name="array">The array.</param>
            <returns><c>true</c> if sorting was successful, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:System.Linq.TimSortExtender.TryComparableTimSort``1(``0[],System.Int32,System.Int32)">
            <summary>Tries sorting as IComparable.</summary>
            <typeparam name="TItem">The type of the item.</typeparam>
            <param name="array">The array.</param>
            <param name="lo">The lower bound.</param>
            <param name="hi">The upper bound.</param>
            <returns><c>true</c> if sorting was successful, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:System.Linq.TimSortExtender.TryComparableTimSort``1(System.Collections.Generic.List{``0})">
            <summary>Tries sorting as IComparable.</summary>
            <typeparam name="TItem">The type of the item.</typeparam>
            <param name="list">The list.</param>
            <returns><c>true</c> if sorting was successful, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:System.Linq.TimSortExtender.TryComparableTimSort``1(System.Collections.Generic.List{``0},System.Int32,System.Int32)">
            <summary>Tries sorting as IComparable.</summary>
            <typeparam name="TItem">The type of the item.</typeparam>
            <param name="list">The list.</param>
            <param name="lo">The lower bound.</param>
            <param name="hi">The upper bound.</param>
            <returns><c>true</c> if sorting was successful, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:System.Linq.TimSortExtender.TryComparableTimSort``1(System.Collections.Generic.IList{``0})">
            <summary>Tries sorting as IComparable.</summary>
            <typeparam name="TItem">The type of the item.</typeparam>
            <param name="list">The list.</param>
            <returns><c>true</c> if sorting was successful, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:System.Linq.TimSortExtender.TryComparableTimSort``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
            <summary>Tries sorting as IComparable.</summary>
            <typeparam name="TItem">The type of the item.</typeparam>
            <param name="list">The list.</param>
            <param name="lo">The lower bound.</param>
            <param name="hi">The upper bound.</param>
            <returns><c>true</c> if sorting was successful, <c>false</c> otherwise.</returns>
        </member>
        <member name="F:System.Linq.TimSortExtender.ItemMemberMap">
            <summary>The map of '_items' member in <see cref="T:System.Collections.Generic.List`1"/></summary>
        </member>
        <member name="M:System.Linq.TimSortExtender.GetInternalMember``1(System.Collections.Generic.List{``0})">
            <summary>Tries to get '_items' member from <see cref="T:System.Collections.Generic.List`1" />.</summary>
            <typeparam name="TItem">The type of the item.</typeparam>
            <param name="list">The list.</param>
            <returns>Array of items (if available)</returns>
        </member>
        <member name="M:System.Linq.TimSortExtender.GetInternalMember``1(System.Collections.Generic.IList{``0})">
            <summary>Tries to cast <see cref="T:System.Collections.Generic.IList`1" /> to <see cref="T:System.Collections.Generic.List`1" />.</summary>
            <typeparam name="TItem">The type of the item.</typeparam>
            <param name="list">The list.</param>
            <returns><see cref="T:System.Collections.Generic.List`1"/> if possible.</returns>
        </member>
        <member name="T:TimSort.ByteArrayTimSort">
            <summary>TimSort implementation for ByteArray.</summary>
        </member>
        <member name="M:TimSort.ByteArrayTimSort.#ctor(System.Byte[])">
            <summary>
            Prevents a default instance of the ByteArrayTimSort class from being created.
            Creates a TimSort instance to maintain the state of an ongoing sort.
            </summary>
            <param name="array">The array to be sorted.</param>
        </member>
        <member name="M:TimSort.ByteArrayTimSort.Sort(System.Byte[])">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
        </member>
        <member name="M:TimSort.ByteArrayTimSort.Sort(System.Byte[],System.Int32,System.Int32)">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
        </member>
        <member name="M:TimSort.ByteArrayTimSort.BinarySort(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
            sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
            If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
            assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
            </summary>
            <param name="array">the array in which a range is to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="start">start the index of the first element in the range that is not already known to be sorted 
            (<c><![CDATA[lo <= start <= hi]]></c>)</param>
        </member>
        <member name="M:TimSort.ByteArrayTimSort.CountRunAndMakeAscending(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Returns the length of the run beginning at the specified position in
            the specified array and reverses the run if it is descending (ensuring
            that the run will always be ascending when the method returns).
            A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
            or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
            For its intended use in a stable mergesort, the strictness of the
            definition of "descending" is needed so that the call can safely
            reverse a descending sequence without violating stability.
            </summary>
            <param name="array">the array in which a run is to be counted and possibly reversed.</param>
            <param name="lo">index of the first element in the run.</param>
            <param name="hi">index after the last element that may be contained in the run. It is required 
            that <c><![CDATA[lo < hi]]></c>.</param>
            <returns>the length of the run beginning at the specified position in the specified array</returns>
        </member>
        <member name="M:TimSort.ByteArrayTimSort.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1.  Run i must be the penultimate 
            or antepenultimate run on the stack. In other words, i must be equal to 
            stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">Stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.ByteArrayTimSort.GallopLeft(System.Byte,System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Locates the position at which to insert the specified key into the
            specified sorted range; if the range contains an element equal to key,
            returns the index of the leftmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. 
            The closer hint is to the result, the faster this method will run.</param>
            <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
            is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
            first k elements of a should precede key, and the last n - k should follow it.</returns>
        </member>
        <member name="M:TimSort.ByteArrayTimSort.GallopRight(System.Byte,System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Like GallopLeft, except that if the range contains an element equal to
            key, GallopRight returns the index after the rightmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
            the faster this method will run.</param>
            <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
        </member>
        <member name="M:TimSort.ByteArrayTimSort.MergeLo(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
            the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
            (a[base1 + len1-1]) must be greater than all elements of the second run.
            For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
            len1 &gt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="M:TimSort.ByteArrayTimSort.MergeHi(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like mergeLo, except that this method should be called only if
            len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="T:TimSort.SByteArrayTimSort">
            <summary>TimSort implementation for SByteArray.</summary>
        </member>
        <member name="M:TimSort.SByteArrayTimSort.#ctor(System.SByte[])">
            <summary>
            Prevents a default instance of the SByteArrayTimSort class from being created.
            Creates a TimSort instance to maintain the state of an ongoing sort.
            </summary>
            <param name="array">The array to be sorted.</param>
        </member>
        <member name="M:TimSort.SByteArrayTimSort.Sort(System.SByte[])">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
        </member>
        <member name="M:TimSort.SByteArrayTimSort.Sort(System.SByte[],System.Int32,System.Int32)">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
        </member>
        <member name="M:TimSort.SByteArrayTimSort.BinarySort(System.SByte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
            sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
            If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
            assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
            </summary>
            <param name="array">the array in which a range is to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="start">start the index of the first element in the range that is not already known to be sorted 
            (<c><![CDATA[lo <= start <= hi]]></c>)</param>
        </member>
        <member name="M:TimSort.SByteArrayTimSort.CountRunAndMakeAscending(System.SByte[],System.Int32,System.Int32)">
            <summary>
            Returns the length of the run beginning at the specified position in
            the specified array and reverses the run if it is descending (ensuring
            that the run will always be ascending when the method returns).
            A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
            or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
            For its intended use in a stable mergesort, the strictness of the
            definition of "descending" is needed so that the call can safely
            reverse a descending sequence without violating stability.
            </summary>
            <param name="array">the array in which a run is to be counted and possibly reversed.</param>
            <param name="lo">index of the first element in the run.</param>
            <param name="hi">index after the last element that may be contained in the run. It is required 
            that <c><![CDATA[lo < hi]]></c>.</param>
            <returns>the length of the run beginning at the specified position in the specified array</returns>
        </member>
        <member name="M:TimSort.SByteArrayTimSort.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1.  Run i must be the penultimate 
            or antepenultimate run on the stack. In other words, i must be equal to 
            stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">Stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.SByteArrayTimSort.GallopLeft(System.SByte,System.SByte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Locates the position at which to insert the specified key into the
            specified sorted range; if the range contains an element equal to key,
            returns the index of the leftmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. 
            The closer hint is to the result, the faster this method will run.</param>
            <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
            is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
            first k elements of a should precede key, and the last n - k should follow it.</returns>
        </member>
        <member name="M:TimSort.SByteArrayTimSort.GallopRight(System.SByte,System.SByte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Like GallopLeft, except that if the range contains an element equal to
            key, GallopRight returns the index after the rightmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
            the faster this method will run.</param>
            <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
        </member>
        <member name="M:TimSort.SByteArrayTimSort.MergeLo(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
            the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
            (a[base1 + len1-1]) must be greater than all elements of the second run.
            For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
            len1 &gt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="M:TimSort.SByteArrayTimSort.MergeHi(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like mergeLo, except that this method should be called only if
            len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="T:TimSort.Int16ArrayTimSort">
            <summary>TimSort implementation for Int16Array.</summary>
        </member>
        <member name="M:TimSort.Int16ArrayTimSort.#ctor(System.Int16[])">
            <summary>
            Prevents a default instance of the Int16ArrayTimSort class from being created.
            Creates a TimSort instance to maintain the state of an ongoing sort.
            </summary>
            <param name="array">The array to be sorted.</param>
        </member>
        <member name="M:TimSort.Int16ArrayTimSort.Sort(System.Int16[])">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
        </member>
        <member name="M:TimSort.Int16ArrayTimSort.Sort(System.Int16[],System.Int32,System.Int32)">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
        </member>
        <member name="M:TimSort.Int16ArrayTimSort.BinarySort(System.Int16[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
            sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
            If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
            assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
            </summary>
            <param name="array">the array in which a range is to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="start">start the index of the first element in the range that is not already known to be sorted 
            (<c><![CDATA[lo <= start <= hi]]></c>)</param>
        </member>
        <member name="M:TimSort.Int16ArrayTimSort.CountRunAndMakeAscending(System.Int16[],System.Int32,System.Int32)">
            <summary>
            Returns the length of the run beginning at the specified position in
            the specified array and reverses the run if it is descending (ensuring
            that the run will always be ascending when the method returns).
            A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
            or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
            For its intended use in a stable mergesort, the strictness of the
            definition of "descending" is needed so that the call can safely
            reverse a descending sequence without violating stability.
            </summary>
            <param name="array">the array in which a run is to be counted and possibly reversed.</param>
            <param name="lo">index of the first element in the run.</param>
            <param name="hi">index after the last element that may be contained in the run. It is required 
            that <c><![CDATA[lo < hi]]></c>.</param>
            <returns>the length of the run beginning at the specified position in the specified array</returns>
        </member>
        <member name="M:TimSort.Int16ArrayTimSort.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1.  Run i must be the penultimate 
            or antepenultimate run on the stack. In other words, i must be equal to 
            stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">Stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.Int16ArrayTimSort.GallopLeft(System.Int16,System.Int16[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Locates the position at which to insert the specified key into the
            specified sorted range; if the range contains an element equal to key,
            returns the index of the leftmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. 
            The closer hint is to the result, the faster this method will run.</param>
            <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
            is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
            first k elements of a should precede key, and the last n - k should follow it.</returns>
        </member>
        <member name="M:TimSort.Int16ArrayTimSort.GallopRight(System.Int16,System.Int16[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Like GallopLeft, except that if the range contains an element equal to
            key, GallopRight returns the index after the rightmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
            the faster this method will run.</param>
            <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
        </member>
        <member name="M:TimSort.Int16ArrayTimSort.MergeLo(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
            the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
            (a[base1 + len1-1]) must be greater than all elements of the second run.
            For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
            len1 &gt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="M:TimSort.Int16ArrayTimSort.MergeHi(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like mergeLo, except that this method should be called only if
            len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="T:TimSort.UInt16ArrayTimSort">
            <summary>TimSort implementation for UInt16Array.</summary>
        </member>
        <member name="M:TimSort.UInt16ArrayTimSort.#ctor(System.UInt16[])">
            <summary>
            Prevents a default instance of the UInt16ArrayTimSort class from being created.
            Creates a TimSort instance to maintain the state of an ongoing sort.
            </summary>
            <param name="array">The array to be sorted.</param>
        </member>
        <member name="M:TimSort.UInt16ArrayTimSort.Sort(System.UInt16[])">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
        </member>
        <member name="M:TimSort.UInt16ArrayTimSort.Sort(System.UInt16[],System.Int32,System.Int32)">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
        </member>
        <member name="M:TimSort.UInt16ArrayTimSort.BinarySort(System.UInt16[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
            sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
            If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
            assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
            </summary>
            <param name="array">the array in which a range is to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="start">start the index of the first element in the range that is not already known to be sorted 
            (<c><![CDATA[lo <= start <= hi]]></c>)</param>
        </member>
        <member name="M:TimSort.UInt16ArrayTimSort.CountRunAndMakeAscending(System.UInt16[],System.Int32,System.Int32)">
            <summary>
            Returns the length of the run beginning at the specified position in
            the specified array and reverses the run if it is descending (ensuring
            that the run will always be ascending when the method returns).
            A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
            or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
            For its intended use in a stable mergesort, the strictness of the
            definition of "descending" is needed so that the call can safely
            reverse a descending sequence without violating stability.
            </summary>
            <param name="array">the array in which a run is to be counted and possibly reversed.</param>
            <param name="lo">index of the first element in the run.</param>
            <param name="hi">index after the last element that may be contained in the run. It is required 
            that <c><![CDATA[lo < hi]]></c>.</param>
            <returns>the length of the run beginning at the specified position in the specified array</returns>
        </member>
        <member name="M:TimSort.UInt16ArrayTimSort.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1.  Run i must be the penultimate 
            or antepenultimate run on the stack. In other words, i must be equal to 
            stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">Stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.UInt16ArrayTimSort.GallopLeft(System.UInt16,System.UInt16[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Locates the position at which to insert the specified key into the
            specified sorted range; if the range contains an element equal to key,
            returns the index of the leftmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. 
            The closer hint is to the result, the faster this method will run.</param>
            <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
            is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
            first k elements of a should precede key, and the last n - k should follow it.</returns>
        </member>
        <member name="M:TimSort.UInt16ArrayTimSort.GallopRight(System.UInt16,System.UInt16[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Like GallopLeft, except that if the range contains an element equal to
            key, GallopRight returns the index after the rightmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
            the faster this method will run.</param>
            <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
        </member>
        <member name="M:TimSort.UInt16ArrayTimSort.MergeLo(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
            the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
            (a[base1 + len1-1]) must be greater than all elements of the second run.
            For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
            len1 &gt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="M:TimSort.UInt16ArrayTimSort.MergeHi(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like mergeLo, except that this method should be called only if
            len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="T:TimSort.Int32ArrayTimSort">
            <summary>TimSort implementation for Int32Array.</summary>
        </member>
        <member name="M:TimSort.Int32ArrayTimSort.#ctor(System.Int32[])">
            <summary>
            Prevents a default instance of the Int32ArrayTimSort class from being created.
            Creates a TimSort instance to maintain the state of an ongoing sort.
            </summary>
            <param name="array">The array to be sorted.</param>
        </member>
        <member name="M:TimSort.Int32ArrayTimSort.Sort(System.Int32[],System.Int32@,System.Int32@,System.Int32@)">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
        </member>
        <member name="M:TimSort.Int32ArrayTimSort.Sort(System.Int32[],System.Int32,System.Int32)">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
        </member>
        <member name="M:TimSort.Int32ArrayTimSort.BinarySort(System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
            sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
            If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
            assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
            </summary>
            <param name="array">the array in which a range is to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="start">start the index of the first element in the range that is not already known to be sorted 
            (<c><![CDATA[lo <= start <= hi]]></c>)</param>
        </member>
        <member name="M:TimSort.Int32ArrayTimSort.CountRunAndMakeAscending(System.Int32[],System.Int32,System.Int32)">
            <summary>
            Returns the length of the run beginning at the specified position in
            the specified array and reverses the run if it is descending (ensuring
            that the run will always be ascending when the method returns).
            A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
            or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
            For its intended use in a stable mergesort, the strictness of the
            definition of "descending" is needed so that the call can safely
            reverse a descending sequence without violating stability.
            </summary>
            <param name="array">the array in which a run is to be counted and possibly reversed.</param>
            <param name="lo">index of the first element in the run.</param>
            <param name="hi">index after the last element that may be contained in the run. It is required 
            that <c><![CDATA[lo < hi]]></c>.</param>
            <returns>the length of the run beginning at the specified position in the specified array</returns>
        </member>
        <member name="M:TimSort.Int32ArrayTimSort.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1.  Run i must be the penultimate 
            or antepenultimate run on the stack. In other words, i must be equal to 
            stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">Stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.Int32ArrayTimSort.GallopLeft(System.Int32,System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Locates the position at which to insert the specified key into the
            specified sorted range; if the range contains an element equal to key,
            returns the index of the leftmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. 
            The closer hint is to the result, the faster this method will run.</param>
            <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
            is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
            first k elements of a should precede key, and the last n - k should follow it.</returns>
        </member>
        <member name="M:TimSort.Int32ArrayTimSort.GallopRight(System.Int32,System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Like GallopLeft, except that if the range contains an element equal to
            key, GallopRight returns the index after the rightmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
            the faster this method will run.</param>
            <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
        </member>
        <member name="M:TimSort.Int32ArrayTimSort.MergeLo(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
            the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
            (a[base1 + len1-1]) must be greater than all elements of the second run.
            For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
            len1 &gt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="M:TimSort.Int32ArrayTimSort.MergeHi(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like mergeLo, except that this method should be called only if
            len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="T:TimSort.UInt32ArrayTimSort">
            <summary>TimSort implementation for UInt32Array.</summary>
        </member>
        <member name="M:TimSort.UInt32ArrayTimSort.#ctor(System.UInt32[])">
            <summary>
            Prevents a default instance of the UInt32ArrayTimSort class from being created.
            Creates a TimSort instance to maintain the state of an ongoing sort.
            </summary>
            <param name="array">The array to be sorted.</param>
        </member>
        <member name="M:TimSort.UInt32ArrayTimSort.Sort(System.UInt32[])">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
        </member>
        <member name="M:TimSort.UInt32ArrayTimSort.Sort(System.UInt32[],System.Int32,System.Int32)">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
        </member>
        <member name="M:TimSort.UInt32ArrayTimSort.BinarySort(System.UInt32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
            sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
            If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
            assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
            </summary>
            <param name="array">the array in which a range is to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="start">start the index of the first element in the range that is not already known to be sorted 
            (<c><![CDATA[lo <= start <= hi]]></c>)</param>
        </member>
        <member name="M:TimSort.UInt32ArrayTimSort.CountRunAndMakeAscending(System.UInt32[],System.Int32,System.Int32)">
            <summary>
            Returns the length of the run beginning at the specified position in
            the specified array and reverses the run if it is descending (ensuring
            that the run will always be ascending when the method returns).
            A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
            or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
            For its intended use in a stable mergesort, the strictness of the
            definition of "descending" is needed so that the call can safely
            reverse a descending sequence without violating stability.
            </summary>
            <param name="array">the array in which a run is to be counted and possibly reversed.</param>
            <param name="lo">index of the first element in the run.</param>
            <param name="hi">index after the last element that may be contained in the run. It is required 
            that <c><![CDATA[lo < hi]]></c>.</param>
            <returns>the length of the run beginning at the specified position in the specified array</returns>
        </member>
        <member name="M:TimSort.UInt32ArrayTimSort.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1.  Run i must be the penultimate 
            or antepenultimate run on the stack. In other words, i must be equal to 
            stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">Stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.UInt32ArrayTimSort.GallopLeft(System.UInt32,System.UInt32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Locates the position at which to insert the specified key into the
            specified sorted range; if the range contains an element equal to key,
            returns the index of the leftmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. 
            The closer hint is to the result, the faster this method will run.</param>
            <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
            is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
            first k elements of a should precede key, and the last n - k should follow it.</returns>
        </member>
        <member name="M:TimSort.UInt32ArrayTimSort.GallopRight(System.UInt32,System.UInt32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Like GallopLeft, except that if the range contains an element equal to
            key, GallopRight returns the index after the rightmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
            the faster this method will run.</param>
            <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
        </member>
        <member name="M:TimSort.UInt32ArrayTimSort.MergeLo(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
            the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
            (a[base1 + len1-1]) must be greater than all elements of the second run.
            For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
            len1 &gt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="M:TimSort.UInt32ArrayTimSort.MergeHi(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like mergeLo, except that this method should be called only if
            len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="T:TimSort.Int64ArrayTimSort">
            <summary>TimSort implementation for Int64Array.</summary>
        </member>
        <member name="M:TimSort.Int64ArrayTimSort.#ctor(System.Int64[])">
            <summary>
            Prevents a default instance of the Int64ArrayTimSort class from being created.
            Creates a TimSort instance to maintain the state of an ongoing sort.
            </summary>
            <param name="array">The array to be sorted.</param>
        </member>
        <member name="M:TimSort.Int64ArrayTimSort.Sort(System.Int64[])">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
        </member>
        <member name="M:TimSort.Int64ArrayTimSort.Sort(System.Int64[],System.Int32,System.Int32)">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
        </member>
        <member name="M:TimSort.Int64ArrayTimSort.BinarySort(System.Int64[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
            sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
            If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
            assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
            </summary>
            <param name="array">the array in which a range is to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="start">start the index of the first element in the range that is not already known to be sorted 
            (<c><![CDATA[lo <= start <= hi]]></c>)</param>
        </member>
        <member name="M:TimSort.Int64ArrayTimSort.CountRunAndMakeAscending(System.Int64[],System.Int32,System.Int32)">
            <summary>
            Returns the length of the run beginning at the specified position in
            the specified array and reverses the run if it is descending (ensuring
            that the run will always be ascending when the method returns).
            A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
            or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
            For its intended use in a stable mergesort, the strictness of the
            definition of "descending" is needed so that the call can safely
            reverse a descending sequence without violating stability.
            </summary>
            <param name="array">the array in which a run is to be counted and possibly reversed.</param>
            <param name="lo">index of the first element in the run.</param>
            <param name="hi">index after the last element that may be contained in the run. It is required 
            that <c><![CDATA[lo < hi]]></c>.</param>
            <returns>the length of the run beginning at the specified position in the specified array</returns>
        </member>
        <member name="M:TimSort.Int64ArrayTimSort.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1.  Run i must be the penultimate 
            or antepenultimate run on the stack. In other words, i must be equal to 
            stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">Stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.Int64ArrayTimSort.GallopLeft(System.Int64,System.Int64[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Locates the position at which to insert the specified key into the
            specified sorted range; if the range contains an element equal to key,
            returns the index of the leftmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. 
            The closer hint is to the result, the faster this method will run.</param>
            <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
            is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
            first k elements of a should precede key, and the last n - k should follow it.</returns>
        </member>
        <member name="M:TimSort.Int64ArrayTimSort.GallopRight(System.Int64,System.Int64[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Like GallopLeft, except that if the range contains an element equal to
            key, GallopRight returns the index after the rightmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
            the faster this method will run.</param>
            <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
        </member>
        <member name="M:TimSort.Int64ArrayTimSort.MergeLo(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
            the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
            (a[base1 + len1-1]) must be greater than all elements of the second run.
            For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
            len1 &gt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="M:TimSort.Int64ArrayTimSort.MergeHi(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like mergeLo, except that this method should be called only if
            len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="T:TimSort.UInt64ArrayTimSort">
            <summary>TimSort implementation for UInt64Array.</summary>
        </member>
        <member name="M:TimSort.UInt64ArrayTimSort.#ctor(System.UInt64[])">
            <summary>
            Prevents a default instance of the UInt64ArrayTimSort class from being created.
            Creates a TimSort instance to maintain the state of an ongoing sort.
            </summary>
            <param name="array">The array to be sorted.</param>
        </member>
        <member name="M:TimSort.UInt64ArrayTimSort.Sort(System.UInt64[])">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
        </member>
        <member name="M:TimSort.UInt64ArrayTimSort.Sort(System.UInt64[],System.Int32,System.Int32)">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
        </member>
        <member name="M:TimSort.UInt64ArrayTimSort.BinarySort(System.UInt64[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
            sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
            If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
            assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
            </summary>
            <param name="array">the array in which a range is to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="start">start the index of the first element in the range that is not already known to be sorted 
            (<c><![CDATA[lo <= start <= hi]]></c>)</param>
        </member>
        <member name="M:TimSort.UInt64ArrayTimSort.CountRunAndMakeAscending(System.UInt64[],System.Int32,System.Int32)">
            <summary>
            Returns the length of the run beginning at the specified position in
            the specified array and reverses the run if it is descending (ensuring
            that the run will always be ascending when the method returns).
            A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
            or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
            For its intended use in a stable mergesort, the strictness of the
            definition of "descending" is needed so that the call can safely
            reverse a descending sequence without violating stability.
            </summary>
            <param name="array">the array in which a run is to be counted and possibly reversed.</param>
            <param name="lo">index of the first element in the run.</param>
            <param name="hi">index after the last element that may be contained in the run. It is required 
            that <c><![CDATA[lo < hi]]></c>.</param>
            <returns>the length of the run beginning at the specified position in the specified array</returns>
        </member>
        <member name="M:TimSort.UInt64ArrayTimSort.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1.  Run i must be the penultimate 
            or antepenultimate run on the stack. In other words, i must be equal to 
            stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">Stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.UInt64ArrayTimSort.GallopLeft(System.UInt64,System.UInt64[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Locates the position at which to insert the specified key into the
            specified sorted range; if the range contains an element equal to key,
            returns the index of the leftmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. 
            The closer hint is to the result, the faster this method will run.</param>
            <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
            is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
            first k elements of a should precede key, and the last n - k should follow it.</returns>
        </member>
        <member name="M:TimSort.UInt64ArrayTimSort.GallopRight(System.UInt64,System.UInt64[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Like GallopLeft, except that if the range contains an element equal to
            key, GallopRight returns the index after the rightmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
            the faster this method will run.</param>
            <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
        </member>
        <member name="M:TimSort.UInt64ArrayTimSort.MergeLo(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
            the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
            (a[base1 + len1-1]) must be greater than all elements of the second run.
            For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
            len1 &gt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="M:TimSort.UInt64ArrayTimSort.MergeHi(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like mergeLo, except that this method should be called only if
            len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="T:TimSort.SingleArrayTimSort">
            <summary>TimSort implementation for SingleArray.</summary>
        </member>
        <member name="M:TimSort.SingleArrayTimSort.#ctor(System.Single[])">
            <summary>
            Prevents a default instance of the SingleArrayTimSort class from being created.
            Creates a TimSort instance to maintain the state of an ongoing sort.
            </summary>
            <param name="array">The array to be sorted.</param>
        </member>
        <member name="M:TimSort.SingleArrayTimSort.Sort(System.Single[])">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
        </member>
        <member name="M:TimSort.SingleArrayTimSort.Sort(System.Single[],System.Int32,System.Int32)">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
        </member>
        <member name="M:TimSort.SingleArrayTimSort.BinarySort(System.Single[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
            sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
            If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
            assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
            </summary>
            <param name="array">the array in which a range is to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="start">start the index of the first element in the range that is not already known to be sorted 
            (<c><![CDATA[lo <= start <= hi]]></c>)</param>
        </member>
        <member name="M:TimSort.SingleArrayTimSort.CountRunAndMakeAscending(System.Single[],System.Int32,System.Int32)">
            <summary>
            Returns the length of the run beginning at the specified position in
            the specified array and reverses the run if it is descending (ensuring
            that the run will always be ascending when the method returns).
            A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
            or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
            For its intended use in a stable mergesort, the strictness of the
            definition of "descending" is needed so that the call can safely
            reverse a descending sequence without violating stability.
            </summary>
            <param name="array">the array in which a run is to be counted and possibly reversed.</param>
            <param name="lo">index of the first element in the run.</param>
            <param name="hi">index after the last element that may be contained in the run. It is required 
            that <c><![CDATA[lo < hi]]></c>.</param>
            <returns>the length of the run beginning at the specified position in the specified array</returns>
        </member>
        <member name="M:TimSort.SingleArrayTimSort.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1.  Run i must be the penultimate 
            or antepenultimate run on the stack. In other words, i must be equal to 
            stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">Stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.SingleArrayTimSort.GallopLeft(System.Single,System.Single[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Locates the position at which to insert the specified key into the
            specified sorted range; if the range contains an element equal to key,
            returns the index of the leftmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. 
            The closer hint is to the result, the faster this method will run.</param>
            <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
            is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
            first k elements of a should precede key, and the last n - k should follow it.</returns>
        </member>
        <member name="M:TimSort.SingleArrayTimSort.GallopRight(System.Single,System.Single[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Like GallopLeft, except that if the range contains an element equal to
            key, GallopRight returns the index after the rightmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
            the faster this method will run.</param>
            <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
        </member>
        <member name="M:TimSort.SingleArrayTimSort.MergeLo(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
            the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
            (a[base1 + len1-1]) must be greater than all elements of the second run.
            For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
            len1 &gt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="M:TimSort.SingleArrayTimSort.MergeHi(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like mergeLo, except that this method should be called only if
            len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="T:TimSort.DoubleArrayTimSort">
            <summary>TimSort implementation for DoubleArray.</summary>
        </member>
        <member name="M:TimSort.DoubleArrayTimSort.#ctor(System.Double[])">
            <summary>
            Prevents a default instance of the DoubleArrayTimSort class from being created.
            Creates a TimSort instance to maintain the state of an ongoing sort.
            </summary>
            <param name="array">The array to be sorted.</param>
        </member>
        <member name="M:TimSort.DoubleArrayTimSort.Sort(System.Double[])">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
        </member>
        <member name="M:TimSort.DoubleArrayTimSort.Sort(System.Double[],System.Int32,System.Int32)">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
        </member>
        <member name="M:TimSort.DoubleArrayTimSort.BinarySort(System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
            sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
            If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
            assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
            </summary>
            <param name="array">the array in which a range is to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="start">start the index of the first element in the range that is not already known to be sorted 
            (<c><![CDATA[lo <= start <= hi]]></c>)</param>
        </member>
        <member name="M:TimSort.DoubleArrayTimSort.CountRunAndMakeAscending(System.Double[],System.Int32,System.Int32)">
            <summary>
            Returns the length of the run beginning at the specified position in
            the specified array and reverses the run if it is descending (ensuring
            that the run will always be ascending when the method returns).
            A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
            or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
            For its intended use in a stable mergesort, the strictness of the
            definition of "descending" is needed so that the call can safely
            reverse a descending sequence without violating stability.
            </summary>
            <param name="array">the array in which a run is to be counted and possibly reversed.</param>
            <param name="lo">index of the first element in the run.</param>
            <param name="hi">index after the last element that may be contained in the run. It is required 
            that <c><![CDATA[lo < hi]]></c>.</param>
            <returns>the length of the run beginning at the specified position in the specified array</returns>
        </member>
        <member name="M:TimSort.DoubleArrayTimSort.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1.  Run i must be the penultimate 
            or antepenultimate run on the stack. In other words, i must be equal to 
            stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">Stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.DoubleArrayTimSort.GallopLeft(System.Double,System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Locates the position at which to insert the specified key into the
            specified sorted range; if the range contains an element equal to key,
            returns the index of the leftmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. 
            The closer hint is to the result, the faster this method will run.</param>
            <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
            is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
            first k elements of a should precede key, and the last n - k should follow it.</returns>
        </member>
        <member name="M:TimSort.DoubleArrayTimSort.GallopRight(System.Double,System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Like GallopLeft, except that if the range contains an element equal to
            key, GallopRight returns the index after the rightmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
            the faster this method will run.</param>
            <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
        </member>
        <member name="M:TimSort.DoubleArrayTimSort.MergeLo(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
            the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
            (a[base1 + len1-1]) must be greater than all elements of the second run.
            For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
            len1 &gt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="M:TimSort.DoubleArrayTimSort.MergeHi(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like mergeLo, except that this method should be called only if
            len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="T:TimSort.DecimalArrayTimSort">
            <summary>TimSort implementation for DecimalArray.</summary>
        </member>
        <member name="M:TimSort.DecimalArrayTimSort.#ctor(System.Decimal[])">
            <summary>
            Prevents a default instance of the DecimalArrayTimSort class from being created.
            Creates a TimSort instance to maintain the state of an ongoing sort.
            </summary>
            <param name="array">The array to be sorted.</param>
        </member>
        <member name="M:TimSort.DecimalArrayTimSort.Sort(System.Decimal[])">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
        </member>
        <member name="M:TimSort.DecimalArrayTimSort.Sort(System.Decimal[],System.Int32,System.Int32)">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
        </member>
        <member name="M:TimSort.DecimalArrayTimSort.BinarySort(System.Decimal[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
            sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
            If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
            assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
            </summary>
            <param name="array">the array in which a range is to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="start">start the index of the first element in the range that is not already known to be sorted 
            (<c><![CDATA[lo <= start <= hi]]></c>)</param>
        </member>
        <member name="M:TimSort.DecimalArrayTimSort.CountRunAndMakeAscending(System.Decimal[],System.Int32,System.Int32)">
            <summary>
            Returns the length of the run beginning at the specified position in
            the specified array and reverses the run if it is descending (ensuring
            that the run will always be ascending when the method returns).
            A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
            or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
            For its intended use in a stable mergesort, the strictness of the
            definition of "descending" is needed so that the call can safely
            reverse a descending sequence without violating stability.
            </summary>
            <param name="array">the array in which a run is to be counted and possibly reversed.</param>
            <param name="lo">index of the first element in the run.</param>
            <param name="hi">index after the last element that may be contained in the run. It is required 
            that <c><![CDATA[lo < hi]]></c>.</param>
            <returns>the length of the run beginning at the specified position in the specified array</returns>
        </member>
        <member name="M:TimSort.DecimalArrayTimSort.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1.  Run i must be the penultimate 
            or antepenultimate run on the stack. In other words, i must be equal to 
            stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">Stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.DecimalArrayTimSort.GallopLeft(System.Decimal,System.Decimal[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Locates the position at which to insert the specified key into the
            specified sorted range; if the range contains an element equal to key,
            returns the index of the leftmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. 
            The closer hint is to the result, the faster this method will run.</param>
            <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
            is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
            first k elements of a should precede key, and the last n - k should follow it.</returns>
        </member>
        <member name="M:TimSort.DecimalArrayTimSort.GallopRight(System.Decimal,System.Decimal[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Like GallopLeft, except that if the range contains an element equal to
            key, GallopRight returns the index after the rightmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
            the faster this method will run.</param>
            <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
        </member>
        <member name="M:TimSort.DecimalArrayTimSort.MergeLo(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
            the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
            (a[base1 + len1-1]) must be greater than all elements of the second run.
            For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
            len1 &gt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="M:TimSort.DecimalArrayTimSort.MergeHi(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like mergeLo, except that this method should be called only if
            len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="T:TimSort.CharArrayTimSort">
            <summary>TimSort implementation for CharArray.</summary>
        </member>
        <member name="M:TimSort.CharArrayTimSort.#ctor(System.Char[])">
            <summary>
            Prevents a default instance of the CharArrayTimSort class from being created.
            Creates a TimSort instance to maintain the state of an ongoing sort.
            </summary>
            <param name="array">The array to be sorted.</param>
        </member>
        <member name="M:TimSort.CharArrayTimSort.Sort(System.Char[])">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
        </member>
        <member name="M:TimSort.CharArrayTimSort.Sort(System.Char[],System.Int32,System.Int32)">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
        </member>
        <member name="M:TimSort.CharArrayTimSort.BinarySort(System.Char[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
            sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
            If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
            assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
            </summary>
            <param name="array">the array in which a range is to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="start">start the index of the first element in the range that is not already known to be sorted 
            (<c><![CDATA[lo <= start <= hi]]></c>)</param>
        </member>
        <member name="M:TimSort.CharArrayTimSort.CountRunAndMakeAscending(System.Char[],System.Int32,System.Int32)">
            <summary>
            Returns the length of the run beginning at the specified position in
            the specified array and reverses the run if it is descending (ensuring
            that the run will always be ascending when the method returns).
            A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
            or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
            For its intended use in a stable mergesort, the strictness of the
            definition of "descending" is needed so that the call can safely
            reverse a descending sequence without violating stability.
            </summary>
            <param name="array">the array in which a run is to be counted and possibly reversed.</param>
            <param name="lo">index of the first element in the run.</param>
            <param name="hi">index after the last element that may be contained in the run. It is required 
            that <c><![CDATA[lo < hi]]></c>.</param>
            <returns>the length of the run beginning at the specified position in the specified array</returns>
        </member>
        <member name="M:TimSort.CharArrayTimSort.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1.  Run i must be the penultimate 
            or antepenultimate run on the stack. In other words, i must be equal to 
            stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">Stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.CharArrayTimSort.GallopLeft(System.Char,System.Char[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Locates the position at which to insert the specified key into the
            specified sorted range; if the range contains an element equal to key,
            returns the index of the leftmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. 
            The closer hint is to the result, the faster this method will run.</param>
            <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
            is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
            first k elements of a should precede key, and the last n - k should follow it.</returns>
        </member>
        <member name="M:TimSort.CharArrayTimSort.GallopRight(System.Char,System.Char[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Like GallopLeft, except that if the range contains an element equal to
            key, GallopRight returns the index after the rightmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
            the faster this method will run.</param>
            <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
        </member>
        <member name="M:TimSort.CharArrayTimSort.MergeLo(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
            the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
            (a[base1 + len1-1]) must be greater than all elements of the second run.
            For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
            len1 &gt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="M:TimSort.CharArrayTimSort.MergeHi(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like mergeLo, except that this method should be called only if
            len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="T:TimSort.DateTimeArrayTimSort">
            <summary>TimSort implementation for DateTimeArray.</summary>
        </member>
        <member name="M:TimSort.DateTimeArrayTimSort.#ctor(System.DateTime[])">
            <summary>
            Prevents a default instance of the DateTimeArrayTimSort class from being created.
            Creates a TimSort instance to maintain the state of an ongoing sort.
            </summary>
            <param name="array">The array to be sorted.</param>
        </member>
        <member name="M:TimSort.DateTimeArrayTimSort.Sort(System.DateTime[])">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
        </member>
        <member name="M:TimSort.DateTimeArrayTimSort.Sort(System.DateTime[],System.Int32,System.Int32)">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
        </member>
        <member name="M:TimSort.DateTimeArrayTimSort.BinarySort(System.DateTime[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
            sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
            If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
            assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
            </summary>
            <param name="array">the array in which a range is to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="start">start the index of the first element in the range that is not already known to be sorted 
            (<c><![CDATA[lo <= start <= hi]]></c>)</param>
        </member>
        <member name="M:TimSort.DateTimeArrayTimSort.CountRunAndMakeAscending(System.DateTime[],System.Int32,System.Int32)">
            <summary>
            Returns the length of the run beginning at the specified position in
            the specified array and reverses the run if it is descending (ensuring
            that the run will always be ascending when the method returns).
            A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
            or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
            For its intended use in a stable mergesort, the strictness of the
            definition of "descending" is needed so that the call can safely
            reverse a descending sequence without violating stability.
            </summary>
            <param name="array">the array in which a run is to be counted and possibly reversed.</param>
            <param name="lo">index of the first element in the run.</param>
            <param name="hi">index after the last element that may be contained in the run. It is required 
            that <c><![CDATA[lo < hi]]></c>.</param>
            <returns>the length of the run beginning at the specified position in the specified array</returns>
        </member>
        <member name="M:TimSort.DateTimeArrayTimSort.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1.  Run i must be the penultimate 
            or antepenultimate run on the stack. In other words, i must be equal to 
            stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">Stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.DateTimeArrayTimSort.GallopLeft(System.DateTime,System.DateTime[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Locates the position at which to insert the specified key into the
            specified sorted range; if the range contains an element equal to key,
            returns the index of the leftmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. 
            The closer hint is to the result, the faster this method will run.</param>
            <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
            is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
            first k elements of a should precede key, and the last n - k should follow it.</returns>
        </member>
        <member name="M:TimSort.DateTimeArrayTimSort.GallopRight(System.DateTime,System.DateTime[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Like GallopLeft, except that if the range contains an element equal to
            key, GallopRight returns the index after the rightmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
            the faster this method will run.</param>
            <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
        </member>
        <member name="M:TimSort.DateTimeArrayTimSort.MergeLo(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
            the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
            (a[base1 + len1-1]) must be greater than all elements of the second run.
            For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
            len1 &gt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="M:TimSort.DateTimeArrayTimSort.MergeHi(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like mergeLo, except that this method should be called only if
            len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="T:TimSort.TimeSpanArrayTimSort">
            <summary>TimSort implementation for TimeSpanArray.</summary>
        </member>
        <member name="M:TimSort.TimeSpanArrayTimSort.#ctor(System.TimeSpan[])">
            <summary>
            Prevents a default instance of the TimeSpanArrayTimSort class from being created.
            Creates a TimSort instance to maintain the state of an ongoing sort.
            </summary>
            <param name="array">The array to be sorted.</param>
        </member>
        <member name="M:TimSort.TimeSpanArrayTimSort.Sort(System.TimeSpan[])">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
        </member>
        <member name="M:TimSort.TimeSpanArrayTimSort.Sort(System.TimeSpan[],System.Int32,System.Int32)">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
        </member>
        <member name="M:TimSort.TimeSpanArrayTimSort.BinarySort(System.TimeSpan[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
            sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
            If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
            assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
            </summary>
            <param name="array">the array in which a range is to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="start">start the index of the first element in the range that is not already known to be sorted 
            (<c><![CDATA[lo <= start <= hi]]></c>)</param>
        </member>
        <member name="M:TimSort.TimeSpanArrayTimSort.CountRunAndMakeAscending(System.TimeSpan[],System.Int32,System.Int32)">
            <summary>
            Returns the length of the run beginning at the specified position in
            the specified array and reverses the run if it is descending (ensuring
            that the run will always be ascending when the method returns).
            A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
            or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
            For its intended use in a stable mergesort, the strictness of the
            definition of "descending" is needed so that the call can safely
            reverse a descending sequence without violating stability.
            </summary>
            <param name="array">the array in which a run is to be counted and possibly reversed.</param>
            <param name="lo">index of the first element in the run.</param>
            <param name="hi">index after the last element that may be contained in the run. It is required 
            that <c><![CDATA[lo < hi]]></c>.</param>
            <returns>the length of the run beginning at the specified position in the specified array</returns>
        </member>
        <member name="M:TimSort.TimeSpanArrayTimSort.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1.  Run i must be the penultimate 
            or antepenultimate run on the stack. In other words, i must be equal to 
            stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">Stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.TimeSpanArrayTimSort.GallopLeft(System.TimeSpan,System.TimeSpan[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Locates the position at which to insert the specified key into the
            specified sorted range; if the range contains an element equal to key,
            returns the index of the leftmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. 
            The closer hint is to the result, the faster this method will run.</param>
            <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
            is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
            first k elements of a should precede key, and the last n - k should follow it.</returns>
        </member>
        <member name="M:TimSort.TimeSpanArrayTimSort.GallopRight(System.TimeSpan,System.TimeSpan[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Like GallopLeft, except that if the range contains an element equal to
            key, GallopRight returns the index after the rightmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
            the faster this method will run.</param>
            <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
        </member>
        <member name="M:TimSort.TimeSpanArrayTimSort.MergeLo(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
            the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
            (a[base1 + len1-1]) must be greater than all elements of the second run.
            For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
            len1 &gt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="M:TimSort.TimeSpanArrayTimSort.MergeHi(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like mergeLo, except that this method should be called only if
            len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="T:TimSort.GuidArrayTimSort">
            <summary>TimSort implementation for GuidArray.</summary>
        </member>
        <member name="M:TimSort.GuidArrayTimSort.#ctor(System.Guid[])">
            <summary>
            Prevents a default instance of the GuidArrayTimSort class from being created.
            Creates a TimSort instance to maintain the state of an ongoing sort.
            </summary>
            <param name="array">The array to be sorted.</param>
        </member>
        <member name="M:TimSort.GuidArrayTimSort.Sort(System.Guid[])">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
        </member>
        <member name="M:TimSort.GuidArrayTimSort.Sort(System.Guid[],System.Int32,System.Int32)">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
        </member>
        <member name="M:TimSort.GuidArrayTimSort.BinarySort(System.Guid[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
            sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
            If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
            assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
            </summary>
            <param name="array">the array in which a range is to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="start">start the index of the first element in the range that is not already known to be sorted 
            (<c><![CDATA[lo <= start <= hi]]></c>)</param>
        </member>
        <member name="M:TimSort.GuidArrayTimSort.CountRunAndMakeAscending(System.Guid[],System.Int32,System.Int32)">
            <summary>
            Returns the length of the run beginning at the specified position in
            the specified array and reverses the run if it is descending (ensuring
            that the run will always be ascending when the method returns).
            A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
            or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
            For its intended use in a stable mergesort, the strictness of the
            definition of "descending" is needed so that the call can safely
            reverse a descending sequence without violating stability.
            </summary>
            <param name="array">the array in which a run is to be counted and possibly reversed.</param>
            <param name="lo">index of the first element in the run.</param>
            <param name="hi">index after the last element that may be contained in the run. It is required 
            that <c><![CDATA[lo < hi]]></c>.</param>
            <returns>the length of the run beginning at the specified position in the specified array</returns>
        </member>
        <member name="M:TimSort.GuidArrayTimSort.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1.  Run i must be the penultimate 
            or antepenultimate run on the stack. In other words, i must be equal to 
            stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">Stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.GuidArrayTimSort.GallopLeft(System.Guid,System.Guid[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Locates the position at which to insert the specified key into the
            specified sorted range; if the range contains an element equal to key,
            returns the index of the leftmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. 
            The closer hint is to the result, the faster this method will run.</param>
            <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
            is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
            first k elements of a should precede key, and the last n - k should follow it.</returns>
        </member>
        <member name="M:TimSort.GuidArrayTimSort.GallopRight(System.Guid,System.Guid[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Like GallopLeft, except that if the range contains an element equal to
            key, GallopRight returns the index after the rightmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
            the faster this method will run.</param>
            <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
        </member>
        <member name="M:TimSort.GuidArrayTimSort.MergeLo(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
            the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
            (a[base1 + len1-1]) must be greater than all elements of the second run.
            For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
            len1 &gt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="M:TimSort.GuidArrayTimSort.MergeHi(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like mergeLo, except that this method should be called only if
            len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="T:TimSort.AnyArrayTimSort`1">
            <summary>TimSort implementation for AnyArray.</summary>
            <typeparam name="T">Type of item.</typeparam>
        </member>
        <member name="F:TimSort.AnyArrayTimSort`1._comparer">
            <summary>The comparator for this sort.</summary>
        </member>
        <member name="M:TimSort.AnyArrayTimSort`1.#ctor(`0[],System.Comparison{`0})">
            <summary>
            Prevents a default instance of the AnyArrayTimSort&lt;T&gt; class from being created.
            Creates a TimSort instance to maintain the state of an ongoing sort.
            </summary>
            <param name="array">The array to be sorted.</param>
            <param name="comparer">The comparator to determine the order of the sort.</param>
        </member>
        <member name="M:TimSort.AnyArrayTimSort`1.Sort(`0[],System.Comparison{`0})">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="comparer">Comparer.</param>
        </member>
        <member name="M:TimSort.AnyArrayTimSort`1.Sort(`0[],System.Int32,System.Int32,System.Comparison{`0})">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="comparer">The comparator to determine the order of the sort.</param>
        </member>
        <member name="M:TimSort.AnyArrayTimSort`1.BinarySort(`0[],System.Int32,System.Int32,System.Int32,System.Comparison{`0})">
            <summary>
            Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
            sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
            If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
            assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
            </summary>
            <param name="array">the array in which a range is to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="start">start the index of the first element in the range that is not already known to be sorted 
            (<c><![CDATA[lo <= start <= hi]]></c>)</param>
            <param name="comparer">The comparator to used for the sort.</param>
        </member>
        <member name="M:TimSort.AnyArrayTimSort`1.CountRunAndMakeAscending(`0[],System.Int32,System.Int32,System.Comparison{`0})">
            <summary>
            Returns the length of the run beginning at the specified position in
            the specified array and reverses the run if it is descending (ensuring
            that the run will always be ascending when the method returns).
            A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
            or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
            For its intended use in a stable mergesort, the strictness of the
            definition of "descending" is needed so that the call can safely
            reverse a descending sequence without violating stability.
            </summary>
            <param name="array">the array in which a run is to be counted and possibly reversed.</param>
            <param name="lo">index of the first element in the run.</param>
            <param name="hi">index after the last element that may be contained in the run. It is required 
            that <c><![CDATA[lo < hi]]></c>.</param>
            <param name="comparer">the comparator to used for the sort.</param>
            <returns>the length of the run beginning at the specified position in the specified array</returns>
        </member>
        <member name="M:TimSort.AnyArrayTimSort`1.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1.  Run i must be the penultimate 
            or antepenultimate run on the stack. In other words, i must be equal to 
            stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">Stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.AnyArrayTimSort`1.GallopLeft(`0,`0[],System.Int32,System.Int32,System.Int32,System.Comparison{`0})">
            <summary>
            Locates the position at which to insert the specified key into the
            specified sorted range; if the range contains an element equal to key,
            returns the index of the leftmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. 
            The closer hint is to the result, the faster this method will run.</param>
            <param name="comparer">the comparator used to order the range, and to search.</param>
            <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
            is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
            first k elements of a should precede key, and the last n - k should follow it.</returns>
        </member>
        <member name="M:TimSort.AnyArrayTimSort`1.GallopRight(`0,`0[],System.Int32,System.Int32,System.Int32,System.Comparison{`0})">
            <summary>
            Like GallopLeft, except that if the range contains an element equal to
            key, GallopRight returns the index after the rightmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
            the faster this method will run.</param>
            <param name="comparer">the comparator used to order the range, and to search.</param>
            <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
        </member>
        <member name="M:TimSort.AnyArrayTimSort`1.MergeLo(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
            the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
            (a[base1 + len1-1]) must be greater than all elements of the second run.
            For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
            len1 &gt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="M:TimSort.AnyArrayTimSort`1.MergeHi(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like mergeLo, except that this method should be called only if
            len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="T:TimSort.AnyListTimSort`1">
            <summary>TimSort implementation for AnyList.</summary>
            <typeparam name="T">Type of item.</typeparam>
        </member>
        <member name="F:TimSort.AnyListTimSort`1._comparer">
            <summary>The comparator for this sort.</summary>
        </member>
        <member name="M:TimSort.AnyListTimSort`1.#ctor(System.Collections.Generic.List{`0},System.Comparison{`0})">
            <summary>
            Prevents a default instance of the AnyListTimSort&lt;T&gt; class from being created.
            Creates a TimSort instance to maintain the state of an ongoing sort.
            </summary>
            <param name="array">The array to be sorted.</param>
            <param name="comparer">The comparator to determine the order of the sort.</param>
        </member>
        <member name="M:TimSort.AnyListTimSort`1.Sort(System.Collections.Generic.List{`0},System.Comparison{`0})">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="comparer">Comparer.</param>
        </member>
        <member name="M:TimSort.AnyListTimSort`1.Sort(System.Collections.Generic.List{`0},System.Int32,System.Int32,System.Comparison{`0})">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="comparer">The comparator to determine the order of the sort.</param>
        </member>
        <member name="M:TimSort.AnyListTimSort`1.BinarySort(System.Collections.Generic.List{`0},System.Int32,System.Int32,System.Int32,System.Comparison{`0})">
            <summary>
            Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
            sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
            If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
            assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
            </summary>
            <param name="array">the array in which a range is to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="start">start the index of the first element in the range that is not already known to be sorted 
            (<c><![CDATA[lo <= start <= hi]]></c>)</param>
            <param name="comparer">The comparator to used for the sort.</param>
        </member>
        <member name="M:TimSort.AnyListTimSort`1.CountRunAndMakeAscending(System.Collections.Generic.List{`0},System.Int32,System.Int32,System.Comparison{`0})">
            <summary>
            Returns the length of the run beginning at the specified position in
            the specified array and reverses the run if it is descending (ensuring
            that the run will always be ascending when the method returns).
            A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
            or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
            For its intended use in a stable mergesort, the strictness of the
            definition of "descending" is needed so that the call can safely
            reverse a descending sequence without violating stability.
            </summary>
            <param name="array">the array in which a run is to be counted and possibly reversed.</param>
            <param name="lo">index of the first element in the run.</param>
            <param name="hi">index after the last element that may be contained in the run. It is required 
            that <c><![CDATA[lo < hi]]></c>.</param>
            <param name="comparer">the comparator to used for the sort.</param>
            <returns>the length of the run beginning at the specified position in the specified array</returns>
        </member>
        <member name="M:TimSort.AnyListTimSort`1.IndexedCopyRange(System.Collections.Generic.List{`0},System.Int32,System.Int32,System.Int32)">
            <summary>Copies the range from one array to another.</summary>
            <param name="buffer">The buffer.</param>
            <param name="srcIndex">Source index in array.</param>
            <param name="dstIndex">Target index in array.</param>
            <param name="length">Number of elements to be copied.</param>
        </member>
        <member name="M:TimSort.AnyListTimSort`1.IndexedCopyRange(`0[],System.Int32,System.Collections.Generic.List{`0},System.Int32,System.Int32)">
            <summary>Copies the range from one array to another.</summary>
            <param name="src">The source array.</param>
            <param name="srcIndex">Starting index in source array.</param>
            <param name="dst">The destination array.</param>
            <param name="dstIndex">Starting index in destination array.</param>
            <param name="length">Number of elements to be copied.</param>
        </member>
        <member name="M:TimSort.AnyListTimSort`1.IndexedCopyRange(System.Collections.Generic.List{`0},System.Int32,`0[],System.Int32,System.Int32)">
            <summary>Copies the range from one array to another.</summary>
            <param name="src">The source array.</param>
            <param name="srcIndex">Starting index in source array.</param>
            <param name="dst">The destination array.</param>
            <param name="dstIndex">Starting index in destination array.</param>
            <param name="length">Number of elements to be copied.</param>
        </member>
        <member name="M:TimSort.AnyListTimSort`1.IndexedReverseRange(System.Collections.Generic.List{`0},System.Int32,System.Int32)">
            <summary>Reverse the specified range of the specified array.</summary>
            <param name="array">the array in which a range is to be reversed.</param>
            <param name="lo">the index of the first element in the range to be reversed.</param>
            <param name="hi">the index after the last element in the range to be reversed.</param>
        </member>
        <member name="M:TimSort.AnyListTimSort`1.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1.  Run i must be the penultimate 
            or antepenultimate run on the stack. In other words, i must be equal to 
            stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">Stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.AnyListTimSort`1.GallopLeft(`0,System.Collections.Generic.List{`0},System.Int32,System.Int32,System.Int32,System.Comparison{`0})">
            <summary>
            Locates the position at which to insert the specified key into the
            specified sorted range; if the range contains an element equal to key,
            returns the index of the leftmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. 
            The closer hint is to the result, the faster this method will run.</param>
            <param name="comparer">the comparator used to order the range, and to search.</param>
            <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
            is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
            first k elements of a should precede key, and the last n - k should follow it.</returns>
        </member>
        <member name="M:TimSort.AnyListTimSort`1.GallopRight(`0,System.Collections.Generic.List{`0},System.Int32,System.Int32,System.Int32,System.Comparison{`0})">
            <summary>
            Like GallopLeft, except that if the range contains an element equal to
            key, GallopRight returns the index after the rightmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
            the faster this method will run.</param>
            <param name="comparer">the comparator used to order the range, and to search.</param>
            <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
        </member>
        <member name="M:TimSort.AnyListTimSort`1.MergeLo(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
            the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
            (a[base1 + len1-1]) must be greater than all elements of the second run.
            For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
            len1 &gt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="M:TimSort.AnyListTimSort`1.MergeHi(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like mergeLo, except that this method should be called only if
            len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="T:TimSort.AnyIListTimSort`1">
            <summary>TimSort implementation for AnyIList.</summary>
            <typeparam name="T">Type of item.</typeparam>
        </member>
        <member name="F:TimSort.AnyIListTimSort`1._comparer">
            <summary>The comparator for this sort.</summary>
        </member>
        <member name="M:TimSort.AnyIListTimSort`1.#ctor(System.Collections.Generic.IList{`0},System.Comparison{`0})">
            <summary>
            Prevents a default instance of the AnyIListTimSort&lt;T&gt; class from being created.
            Creates a TimSort instance to maintain the state of an ongoing sort.
            </summary>
            <param name="array">The array to be sorted.</param>
            <param name="comparer">The comparator to determine the order of the sort.</param>
        </member>
        <member name="M:TimSort.AnyIListTimSort`1.Sort(System.Collections.Generic.IList{`0},System.Comparison{`0})">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="comparer">Comparer.</param>
        </member>
        <member name="M:TimSort.AnyIListTimSort`1.Sort(System.Collections.Generic.IList{`0},System.Int32,System.Int32,System.Comparison{`0})">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="comparer">The comparator to determine the order of the sort.</param>
        </member>
        <member name="M:TimSort.AnyIListTimSort`1.BinarySort(System.Collections.Generic.IList{`0},System.Int32,System.Int32,System.Int32,System.Comparison{`0})">
            <summary>
            Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
            sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
            If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
            assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
            </summary>
            <param name="array">the array in which a range is to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="start">start the index of the first element in the range that is not already known to be sorted 
            (<c><![CDATA[lo <= start <= hi]]></c>)</param>
            <param name="comparer">The comparator to used for the sort.</param>
        </member>
        <member name="M:TimSort.AnyIListTimSort`1.CountRunAndMakeAscending(System.Collections.Generic.IList{`0},System.Int32,System.Int32,System.Comparison{`0})">
            <summary>
            Returns the length of the run beginning at the specified position in
            the specified array and reverses the run if it is descending (ensuring
            that the run will always be ascending when the method returns).
            A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
            or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
            For its intended use in a stable mergesort, the strictness of the
            definition of "descending" is needed so that the call can safely
            reverse a descending sequence without violating stability.
            </summary>
            <param name="array">the array in which a run is to be counted and possibly reversed.</param>
            <param name="lo">index of the first element in the run.</param>
            <param name="hi">index after the last element that may be contained in the run. It is required 
            that <c><![CDATA[lo < hi]]></c>.</param>
            <param name="comparer">the comparator to used for the sort.</param>
            <returns>the length of the run beginning at the specified position in the specified array</returns>
        </member>
        <member name="M:TimSort.AnyIListTimSort`1.IndexedCopyRange(System.Collections.Generic.IList{`0},System.Int32,System.Int32,System.Int32)">
            <summary>Copies the range from one array to another.</summary>
            <param name="buffer">The buffer.</param>
            <param name="srcIndex">Source index in array.</param>
            <param name="dstIndex">Target index in array.</param>
            <param name="length">Number of elements to be copied.</param>
        </member>
        <member name="M:TimSort.AnyIListTimSort`1.IndexedCopyRange(`0[],System.Int32,System.Collections.Generic.IList{`0},System.Int32,System.Int32)">
            <summary>Copies the range from one array to another.</summary>
            <param name="src">The source array.</param>
            <param name="srcIndex">Starting index in source array.</param>
            <param name="dst">The destination array.</param>
            <param name="dstIndex">Starting index in destination array.</param>
            <param name="length">Number of elements to be copied.</param>
        </member>
        <member name="M:TimSort.AnyIListTimSort`1.IndexedCopyRange(System.Collections.Generic.IList{`0},System.Int32,`0[],System.Int32,System.Int32)">
            <summary>Copies the range from one array to another.</summary>
            <param name="src">The source array.</param>
            <param name="srcIndex">Starting index in source array.</param>
            <param name="dst">The destination array.</param>
            <param name="dstIndex">Starting index in destination array.</param>
            <param name="length">Number of elements to be copied.</param>
        </member>
        <member name="M:TimSort.AnyIListTimSort`1.IndexedReverseRange(System.Collections.Generic.IList{`0},System.Int32,System.Int32)">
            <summary>Reverse the specified range of the specified array.</summary>
            <param name="array">the array in which a range is to be reversed.</param>
            <param name="lo">the index of the first element in the range to be reversed.</param>
            <param name="hi">the index after the last element in the range to be reversed.</param>
        </member>
        <member name="M:TimSort.AnyIListTimSort`1.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1.  Run i must be the penultimate 
            or antepenultimate run on the stack. In other words, i must be equal to 
            stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">Stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.AnyIListTimSort`1.GallopLeft(`0,System.Collections.Generic.IList{`0},System.Int32,System.Int32,System.Int32,System.Comparison{`0})">
            <summary>
            Locates the position at which to insert the specified key into the
            specified sorted range; if the range contains an element equal to key,
            returns the index of the leftmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. 
            The closer hint is to the result, the faster this method will run.</param>
            <param name="comparer">the comparator used to order the range, and to search.</param>
            <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
            is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
            first k elements of a should precede key, and the last n - k should follow it.</returns>
        </member>
        <member name="M:TimSort.AnyIListTimSort`1.GallopRight(`0,System.Collections.Generic.IList{`0},System.Int32,System.Int32,System.Int32,System.Comparison{`0})">
            <summary>
            Like GallopLeft, except that if the range contains an element equal to
            key, GallopRight returns the index after the rightmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
            the faster this method will run.</param>
            <param name="comparer">the comparator used to order the range, and to search.</param>
            <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
        </member>
        <member name="M:TimSort.AnyIListTimSort`1.MergeLo(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
            the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
            (a[base1 + len1-1]) must be greater than all elements of the second run.
            For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
            len1 &gt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="M:TimSort.AnyIListTimSort`1.MergeHi(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like mergeLo, except that this method should be called only if
            len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="T:TimSort.ComparableArrayTimSort`1">
            <summary>TimSort implementation for ComparableArray.</summary>
            <typeparam name="T">Type of item.</typeparam>
        </member>
        <member name="M:TimSort.ComparableArrayTimSort`1.#ctor(`0[])">
            <summary>
            Prevents a default instance of the ComparableArrayTimSort&lt;T&gt; class from being created.
            Creates a TimSort instance to maintain the state of an ongoing sort.
            </summary>
            <param name="array">The array to be sorted.</param>
        </member>
        <member name="M:TimSort.ComparableArrayTimSort`1.Sort(`0[])">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
        </member>
        <member name="M:TimSort.ComparableArrayTimSort`1.Sort(`0[],System.Int32,System.Int32)">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
        </member>
        <member name="M:TimSort.ComparableArrayTimSort`1.BinarySort(`0[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
            sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
            If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
            assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
            </summary>
            <param name="array">the array in which a range is to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="start">start the index of the first element in the range that is not already known to be sorted 
            (<c><![CDATA[lo <= start <= hi]]></c>)</param>
        </member>
        <member name="M:TimSort.ComparableArrayTimSort`1.CountRunAndMakeAscending(`0[],System.Int32,System.Int32)">
            <summary>
            Returns the length of the run beginning at the specified position in
            the specified array and reverses the run if it is descending (ensuring
            that the run will always be ascending when the method returns).
            A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
            or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
            For its intended use in a stable mergesort, the strictness of the
            definition of "descending" is needed so that the call can safely
            reverse a descending sequence without violating stability.
            </summary>
            <param name="array">the array in which a run is to be counted and possibly reversed.</param>
            <param name="lo">index of the first element in the run.</param>
            <param name="hi">index after the last element that may be contained in the run. It is required 
            that <c><![CDATA[lo < hi]]></c>.</param>
            <returns>the length of the run beginning at the specified position in the specified array</returns>
        </member>
        <member name="M:TimSort.ComparableArrayTimSort`1.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1.  Run i must be the penultimate 
            or antepenultimate run on the stack. In other words, i must be equal to 
            stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">Stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.ComparableArrayTimSort`1.GallopLeft(`0,`0[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Locates the position at which to insert the specified key into the
            specified sorted range; if the range contains an element equal to key,
            returns the index of the leftmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. 
            The closer hint is to the result, the faster this method will run.</param>
            <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
            is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
            first k elements of a should precede key, and the last n - k should follow it.</returns>
        </member>
        <member name="M:TimSort.ComparableArrayTimSort`1.GallopRight(`0,`0[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Like GallopLeft, except that if the range contains an element equal to
            key, GallopRight returns the index after the rightmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
            the faster this method will run.</param>
            <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
        </member>
        <member name="M:TimSort.ComparableArrayTimSort`1.MergeLo(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
            the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
            (a[base1 + len1-1]) must be greater than all elements of the second run.
            For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
            len1 &gt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="M:TimSort.ComparableArrayTimSort`1.MergeHi(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like mergeLo, except that this method should be called only if
            len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="T:TimSort.ComparableListTimSort`1">
            <summary>TimSort implementation for ComparableList.</summary>
            <typeparam name="T">Type of item.</typeparam>
        </member>
        <member name="M:TimSort.ComparableListTimSort`1.#ctor(System.Collections.Generic.List{`0})">
            <summary>
            Prevents a default instance of the ComparableListTimSort&lt;T&gt; class from being created.
            Creates a TimSort instance to maintain the state of an ongoing sort.
            </summary>
            <param name="array">The array to be sorted.</param>
        </member>
        <member name="M:TimSort.ComparableListTimSort`1.Sort(System.Collections.Generic.List{`0})">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
        </member>
        <member name="M:TimSort.ComparableListTimSort`1.Sort(System.Collections.Generic.List{`0},System.Int32,System.Int32)">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
        </member>
        <member name="M:TimSort.ComparableListTimSort`1.BinarySort(System.Collections.Generic.List{`0},System.Int32,System.Int32,System.Int32)">
            <summary>
            Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
            sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
            If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
            assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
            </summary>
            <param name="array">the array in which a range is to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="start">start the index of the first element in the range that is not already known to be sorted 
            (<c><![CDATA[lo <= start <= hi]]></c>)</param>
        </member>
        <member name="M:TimSort.ComparableListTimSort`1.CountRunAndMakeAscending(System.Collections.Generic.List{`0},System.Int32,System.Int32)">
            <summary>
            Returns the length of the run beginning at the specified position in
            the specified array and reverses the run if it is descending (ensuring
            that the run will always be ascending when the method returns).
            A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
            or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
            For its intended use in a stable mergesort, the strictness of the
            definition of "descending" is needed so that the call can safely
            reverse a descending sequence without violating stability.
            </summary>
            <param name="array">the array in which a run is to be counted and possibly reversed.</param>
            <param name="lo">index of the first element in the run.</param>
            <param name="hi">index after the last element that may be contained in the run. It is required 
            that <c><![CDATA[lo < hi]]></c>.</param>
            <returns>the length of the run beginning at the specified position in the specified array</returns>
        </member>
        <member name="M:TimSort.ComparableListTimSort`1.IndexedCopyRange(System.Collections.Generic.List{`0},System.Int32,System.Int32,System.Int32)">
            <summary>Copies the range from one array to another.</summary>
            <param name="buffer">The buffer.</param>
            <param name="srcIndex">Source index in array.</param>
            <param name="dstIndex">Target index in array.</param>
            <param name="length">Number of elements to be copied.</param>
        </member>
        <member name="M:TimSort.ComparableListTimSort`1.IndexedCopyRange(`0[],System.Int32,System.Collections.Generic.List{`0},System.Int32,System.Int32)">
            <summary>Copies the range from one array to another.</summary>
            <param name="src">The source array.</param>
            <param name="srcIndex">Starting index in source array.</param>
            <param name="dst">The destination array.</param>
            <param name="dstIndex">Starting index in destination array.</param>
            <param name="length">Number of elements to be copied.</param>
        </member>
        <member name="M:TimSort.ComparableListTimSort`1.IndexedCopyRange(System.Collections.Generic.List{`0},System.Int32,`0[],System.Int32,System.Int32)">
            <summary>Copies the range from one array to another.</summary>
            <param name="src">The source array.</param>
            <param name="srcIndex">Starting index in source array.</param>
            <param name="dst">The destination array.</param>
            <param name="dstIndex">Starting index in destination array.</param>
            <param name="length">Number of elements to be copied.</param>
        </member>
        <member name="M:TimSort.ComparableListTimSort`1.IndexedReverseRange(System.Collections.Generic.List{`0},System.Int32,System.Int32)">
            <summary>Reverse the specified range of the specified array.</summary>
            <param name="array">the array in which a range is to be reversed.</param>
            <param name="lo">the index of the first element in the range to be reversed.</param>
            <param name="hi">the index after the last element in the range to be reversed.</param>
        </member>
        <member name="M:TimSort.ComparableListTimSort`1.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1.  Run i must be the penultimate 
            or antepenultimate run on the stack. In other words, i must be equal to 
            stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">Stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.ComparableListTimSort`1.GallopLeft(`0,System.Collections.Generic.List{`0},System.Int32,System.Int32,System.Int32)">
            <summary>
            Locates the position at which to insert the specified key into the
            specified sorted range; if the range contains an element equal to key,
            returns the index of the leftmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. 
            The closer hint is to the result, the faster this method will run.</param>
            <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
            is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
            first k elements of a should precede key, and the last n - k should follow it.</returns>
        </member>
        <member name="M:TimSort.ComparableListTimSort`1.GallopRight(`0,System.Collections.Generic.List{`0},System.Int32,System.Int32,System.Int32)">
            <summary>
            Like GallopLeft, except that if the range contains an element equal to
            key, GallopRight returns the index after the rightmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
            the faster this method will run.</param>
            <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
        </member>
        <member name="M:TimSort.ComparableListTimSort`1.MergeLo(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
            the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
            (a[base1 + len1-1]) must be greater than all elements of the second run.
            For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
            len1 &gt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="M:TimSort.ComparableListTimSort`1.MergeHi(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like mergeLo, except that this method should be called only if
            len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="T:TimSort.ComparableIListTimSort`1">
            <summary>TimSort implementation for ComparableIList.</summary>
            <typeparam name="T">Type of item.</typeparam>
        </member>
        <member name="M:TimSort.ComparableIListTimSort`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>
            Prevents a default instance of the ComparableIListTimSort&lt;T&gt; class from being created.
            Creates a TimSort instance to maintain the state of an ongoing sort.
            </summary>
            <param name="array">The array to be sorted.</param>
        </member>
        <member name="M:TimSort.ComparableIListTimSort`1.Sort(System.Collections.Generic.IList{`0})">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
        </member>
        <member name="M:TimSort.ComparableIListTimSort`1.Sort(System.Collections.Generic.IList{`0},System.Int32,System.Int32)">
            <summary>Sorts the specified array.</summary>
            <param name="array">Array to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
        </member>
        <member name="M:TimSort.ComparableIListTimSort`1.BinarySort(System.Collections.Generic.IList{`0},System.Int32,System.Int32,System.Int32)">
            <summary>
            Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for 
            sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).
            If the initial part of the specified range is already sorted, this method can take advantage of it: the method 
            assumes that the elements from index <c>lo</c>, inclusive, to <c>start</c>, exclusive are already sorted.
            </summary>
            <param name="array">the array in which a range is to be sorted.</param>
            <param name="lo">the index of the first element in the range to be sorted.</param>
            <param name="hi">the index after the last element in the range to be sorted.</param>
            <param name="start">start the index of the first element in the range that is not already known to be sorted 
            (<c><![CDATA[lo <= start <= hi]]></c>)</param>
        </member>
        <member name="M:TimSort.ComparableIListTimSort`1.CountRunAndMakeAscending(System.Collections.Generic.IList{`0},System.Int32,System.Int32)">
            <summary>
            Returns the length of the run beginning at the specified position in
            the specified array and reverses the run if it is descending (ensuring
            that the run will always be ascending when the method returns).
            A run is the longest ascending sequence with: <c><![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]></c>
            or the longest descending sequence with: <c><![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]></c>
            For its intended use in a stable mergesort, the strictness of the
            definition of "descending" is needed so that the call can safely
            reverse a descending sequence without violating stability.
            </summary>
            <param name="array">the array in which a run is to be counted and possibly reversed.</param>
            <param name="lo">index of the first element in the run.</param>
            <param name="hi">index after the last element that may be contained in the run. It is required 
            that <c><![CDATA[lo < hi]]></c>.</param>
            <returns>the length of the run beginning at the specified position in the specified array</returns>
        </member>
        <member name="M:TimSort.ComparableIListTimSort`1.IndexedCopyRange(System.Collections.Generic.IList{`0},System.Int32,System.Int32,System.Int32)">
            <summary>Copies the range from one array to another.</summary>
            <param name="buffer">The buffer.</param>
            <param name="srcIndex">Source index in array.</param>
            <param name="dstIndex">Target index in array.</param>
            <param name="length">Number of elements to be copied.</param>
        </member>
        <member name="M:TimSort.ComparableIListTimSort`1.IndexedCopyRange(`0[],System.Int32,System.Collections.Generic.IList{`0},System.Int32,System.Int32)">
            <summary>Copies the range from one array to another.</summary>
            <param name="src">The source array.</param>
            <param name="srcIndex">Starting index in source array.</param>
            <param name="dst">The destination array.</param>
            <param name="dstIndex">Starting index in destination array.</param>
            <param name="length">Number of elements to be copied.</param>
        </member>
        <member name="M:TimSort.ComparableIListTimSort`1.IndexedCopyRange(System.Collections.Generic.IList{`0},System.Int32,`0[],System.Int32,System.Int32)">
            <summary>Copies the range from one array to another.</summary>
            <param name="src">The source array.</param>
            <param name="srcIndex">Starting index in source array.</param>
            <param name="dst">The destination array.</param>
            <param name="dstIndex">Starting index in destination array.</param>
            <param name="length">Number of elements to be copied.</param>
        </member>
        <member name="M:TimSort.ComparableIListTimSort`1.IndexedReverseRange(System.Collections.Generic.IList{`0},System.Int32,System.Int32)">
            <summary>Reverse the specified range of the specified array.</summary>
            <param name="array">the array in which a range is to be reversed.</param>
            <param name="lo">the index of the first element in the range to be reversed.</param>
            <param name="hi">the index after the last element in the range to be reversed.</param>
        </member>
        <member name="M:TimSort.ComparableIListTimSort`1.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1.  Run i must be the penultimate 
            or antepenultimate run on the stack. In other words, i must be equal to 
            stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">Stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.ComparableIListTimSort`1.GallopLeft(`0,System.Collections.Generic.IList{`0},System.Int32,System.Int32,System.Int32)">
            <summary>
            Locates the position at which to insert the specified key into the
            specified sorted range; if the range contains an element equal to key,
            returns the index of the leftmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. 
            The closer hint is to the result, the faster this method will run.</param>
            <returns>the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k], pretending that a[b - 1] 
            is minus infinity and a[b + n] is infinity. In other words, key belongs at index b + k; or in other words, the 
            first k elements of a should precede key, and the last n - k should follow it.</returns>
        </member>
        <member name="M:TimSort.ComparableIListTimSort`1.GallopRight(`0,System.Collections.Generic.IList{`0},System.Int32,System.Int32,System.Int32)">
            <summary>
            Like GallopLeft, except that if the range contains an element equal to
            key, GallopRight returns the index after the rightmost equal element.
            </summary>
            <param name="key">the key whose insertion point to search for.</param>
            <param name="array">the array in which to search.</param>
            <param name="lo">the index of the first element in the range.</param>
            <param name="length">the length of the range; must be &gt; 0.</param>
            <param name="hint">the index at which to begin the search, 0 &lt;= hint &lt; n. The closer hint is to the result, 
            the faster this method will run.</param>
            <returns>int k, that 0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</returns>
        </member>
        <member name="M:TimSort.ComparableIListTimSort`1.MergeLo(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than 
            the first element of the second run (a[base1] &gt; a[base2]), and the last element of the first run 
            (a[base1 + len1-1]) must be greater than all elements of the second run.
            For performance, this method should be called only when len1 &lt;= len2; its twin, mergeHi should be called if 
            len1 &gt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="M:TimSort.ComparableIListTimSort`1.MergeHi(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like mergeLo, except that this method should be called only if
            len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2. (Either method may be called if len1 == len2.)
            </summary>
            <param name="base1">index of first element in first run to be merged.</param>
            <param name="len1">length of first run to be merged (must be &gt; 0).</param>
            <param name="base2">index of first element in second run to be merged (must be aBase + aLen).</param>
            <param name="len2">length of second run to be merged (must be &gt; 0).</param>
        </member>
        <member name="T:TimSort.TimSortBase`2">
            <summary>
            TimSortBase is base class for all TimSort specific classes. It contains common methods.
            Should not be used directly.
            </summary>
            <typeparam name="TList">The type of the list.</typeparam>
            <typeparam name="TItem">The type of the item.</typeparam>
        </member>
        <member name="F:TimSort.TimSortBase`2.MIN_MERGE">
            <summary>
            This is the minimum sized sequence that will be merged.  Shorter
            sequences will be lengthened by calling BinarySort.  If the entire
            array is less than this length, no merges will be performed.
            This constant should be a power of two.  It was 64 in Tim Peter's C
            implementation, but 32 was empirically determined to work better in
            this implementation.  In the unlikely event that you set this constant
            to be a number that's not a power of two, you'll need to change the
            <c>minRunLength</c> computation.
            If you decrease this constant, you must change the stackLen
            computation in the TimSort constructor, or you risk an
            ArrayOutOfBounds exception.  See listsort.txt for a discussion
            of the minimum stack length required as a function of the length
            of the array being sorted and the minimum merge sequence length.
            </summary>
        </member>
        <member name="F:TimSort.TimSortBase`2.MIN_GALLOP">
            <summary>
            When we get into galloping mode, we stay there until both runs win less
            often than MIN_GALLOP consecutive times.
            </summary>
        </member>
        <member name="F:TimSort.TimSortBase`2.INITIAL_TMP_STORAGE_LENGTH">
            <summary>
            Maximum initial size of tmp array, which is used for merging. 
            The array can grow to accommodate demand.
            Unlike Tim's original C version, we do not allocate this much storage
            when sorting smaller arrays. This change was required for performance.
            </summary>
        </member>
        <member name="F:TimSort.TimSortBase`2._array">
            <summary>The array being sorted.</summary>
        </member>
        <member name="F:TimSort.TimSortBase`2._arrayLength">
            <summary>Cached length of array, it won't change.</summary>
        </member>
        <member name="F:TimSort.TimSortBase`2._minGallop">
            <summary>
            This controls when we get *into* galloping mode.  It is initialized
            to MIN_GALLOP.  The mergeLo and mergeHi methods nudge it higher for
            random data, and lower for highly structured data.
            </summary>
        </member>
        <member name="F:TimSort.TimSortBase`2._mergeBuffer">
            <summary>
            Temp storage for merges.
            </summary>
        </member>
        <member name="F:TimSort.TimSortBase`2._stackSize">
            <summary>
            A stack of pending runs yet to be merged.  Run i starts at
            address base[i] and extends for len[i] elements.  It's always
            true (so long as the indices are in bounds) that:
            <c>runBase[i] + runLen[i] == runBase[i + 1]</c>
            so we could cut the storage for this, but it's a minor amount,
            and keeping all the info explicit simplifies the code.
            </summary>
        </member>
        <member name="M:TimSort.TimSortBase`2.#ctor(`0,System.Int32)">
            <summary>Initializes a new instance of the <see cref="T:TimSort.TimSortBase`2"/> class.</summary>
            <param name="array">The array.</param>
            <param name="arrayLength">Length of the array.</param>
        </member>
        <member name="M:TimSort.TimSortBase`2.GetMinimumRunLength(System.Int32)">
            <summary>
            Returns the minimum acceptable run length for an array of the specified length. Natural runs shorter than this 
            will be extended with BinarySort.
            Roughly speaking, the computation is:
            If <c>n &lt; MIN_MERGE</c>, return n (it's too small to bother with fancy stuff).
            Else if n is an exact power of 2, return <c>MIN_MERGE/2</c>.
            Else return an int k, <c>MIN_MERGE/2 &lt;= k &lt;= MIN_MERGE</c>, such that <c>n/k</c> is close to, but strictly 
            less than, an exact power of 2. For the rationale, see listsort.txt.
            </summary>
            <param name="n">the length of the array to be sorted.</param>
            <returns>the length of the minimum run to be merged.</returns>
        </member>
        <member name="M:TimSort.TimSortBase`2.MergeAt(System.Int32)">
            <summary>
            Merges the two runs at stack indices i and i+1. 
            Run i must be the penultimate or antepenultimate run on the stack. 
            In other words, i must be equal to stackSize-2 or stackSize-3.
            </summary>
            <param name="runIndex">stack index of the first of the two runs to merge.</param>
        </member>
        <member name="M:TimSort.TimSortBase`2.MergeCollapse">
            <summary>
            Examines the stack of runs waiting to be merged and merges adjacent runs until the stack invariants are
            reestablished: 
            <c><![CDATA[1. runLen[i - 3] > runLen[i - 2] + runLen[i - 1] ]]></c> and 
            <c><![CDATA[2. runLen[i - 2] > runLen[i - 1] ]]></c>
            This method is called each time a new run is pushed onto the stack,
            so the invariants are guaranteed to hold for i &lt; stackSize upon
            entry to the method.
            </summary>
        </member>
        <member name="M:TimSort.TimSortBase`2.MergeForceCollapse">
            <summary>
            Merges all runs on the stack until only one remains.  This method is called once, to complete the sort.
            </summary>
        </member>
        <member name="M:TimSort.TimSortBase`2.PushRun(System.Int32,System.Int32)">
            <summary>
            Pushes the specified run onto the pending-run stack.
            </summary>
            <param name="runBase">index of the first element in the run.</param>
            <param name="runLength">the number of elements in the run.</param>
        </member>
        <member name="M:TimSort.TimSortBase`2.EnsureCapacity(System.Int32)">
            <summary>
            Ensures that the external array tmp has at least the specified
            number of elements, increasing its size if necessary.  The size
            increases exponentially to ensure amortized linear time complexity.
            </summary>
            <param name="minCapacity">the minimum required capacity of the tmp array.</param>
            <returns>tmp, whether or not it grew</returns>
        </member>
        <member name="M:TimSort.TimSortBase`2.CheckRange(System.Int32,System.Int32,System.Int32)">
            <summary>
            Checks that fromIndex and toIndex are in range, and throws an
            appropriate exception if they aren't.
            </summary>
            <param name="arrayLen">the length of the array.</param>
            <param name="fromIndex">the index of the first element of the range.</param>
            <param name="toIndex">the index after the last element of the range.</param>
        </member>
        <member name="M:TimSort.TimSortBase`2.ArrayReverseRange(`1[],System.Int32,System.Int32)">
            <summary>Reverse the specified range of the specified array.</summary>
            <param name="array">the array in which a range is to be reversed.</param>
            <param name="lo">the index of the first element in the range to be reversed.</param>
            <param name="hi">the index after the last element in the range to be reversed.</param>
        </member>
        <member name="M:TimSort.TimSortBase`2.ArrayCopyRange(`1[],System.Int32,System.Int32,System.Int32)">
            <summary>Copies specified array range.</summary>
            <param name="buffer">The buffer.</param>
            <param name="sourceIndex">Index of the source.</param>
            <param name="targetIndex">Index of the target.</param>
            <param name="length">The length.</param>
        </member>
        <member name="M:TimSort.TimSortBase`2.ArrayCopyRange(`1[],System.Int32,`1[],System.Int32,System.Int32)">
            <summary>Copies specified array range.</summary>
            <param name="source">The source.</param>
            <param name="sourceIndex">Index of the source.</param>
            <param name="target">The target.</param>
            <param name="targetIndex">Index of the target.</param>
            <param name="length">The length.</param>
        </member>
    </members>
</doc>
